generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id        Int             @id @default(autoincrement())
  username       String          @unique
  password_hash  String
  role           String          @default("CASHIER")
  transactions   Transaction[]
  stockMovements StockMovement[]

  @@map("users")
}

model Customer {
  customer_id     Int           @id @default(autoincrement())
  name            String
  contact_details String?
  email           String?       @unique
  password_hash   String?
  is_vendor       Boolean       @default(false)
  orders          Order[]
  transactions    Transaction[]

  @@map("customers")
}

model Product {
  product_id       Int               @id @default(autoincrement())
  product_name     String
  category         String
  retail_price     Decimal
  wholesale_price  Decimal
  barcode          String?           @unique
  image_url        String?
  cost_price       Decimal           @default(0) @db.Decimal(10, 2)
  is_archived      Boolean           @default(false)
  inventory        Inventory?
  orderItems       OrderItem[]
  salesForecasts   SalesForecast[]
  transactionItems TransactionItem[]
  eventLogs        EventLogProduct[] // Events affecting this product

  @@map("products")
}

model Inventory {
  inventory_id   Int             @id @default(autoincrement())
  product_id     Int             @unique
  current_stock  Int             @default(0)
  reorder_level  Int             @default(10)
  last_restock   DateTime        @updatedAt
  product        Product         @relation(fields: [product_id], references: [product_id])
  stockMovements StockMovement[]

  @@map("inventory")
}

/// Types of stock movements for audit trail
/// INITIAL_STOCK: Initial stock when product is created
/// RESTOCK: Adding stock from supplier
/// SALE: Stock removed due to sale (automatic)
/// ADJUSTMENT: Manual adjustment (audit, correction)
/// DAMAGE: Stock removed due to damage/spoilage
/// RETURN: Stock added back from customer return
/// INTERNAL_USE: Stock used internally (not sold)
enum StockMovementType {
  INITIAL_STOCK
  RESTOCK
  SALE
  ADJUSTMENT
  DAMAGE
  RETURN
  INTERNAL_USE
}

/// Audit log for all inventory stock changes
/// Every stock change MUST be logged here for accountability
model StockMovement {
  id                Int               @id @default(autoincrement())
  inventory_id      Int
  user_id           Int
  movement_type     StockMovementType
  quantity_change   Int               // Positive for additions, negative for removals
  previous_stock    Int               // Stock before this movement
  new_stock         Int               // Stock after this movement
  reason            String?           // Optional reason/notes
  reference         String?           // Reference number (e.g., supplier invoice, receipt no)
  supplier_name     String?           // Supplier name for RESTOCK movements
  cost_price        Decimal?          @db.Decimal(10, 2) // Cost price at time of restock
  receipt_image_url String?           // Receipt/document image URL for RESTOCK/INITIAL_STOCK
  created_at        DateTime          @default(now())
  inventory         Inventory         @relation(fields: [inventory_id], references: [inventory_id])
  user              User              @relation(fields: [user_id], references: [user_id])

  @@index([inventory_id])
  @@index([user_id])
  @@index([movement_type])
  @@index([created_at])
  @@map("stock_movements")
}

model Order {
  order_id     Int          @id @default(autoincrement())
  customer_id  Int
  order_date   DateTime     @default(now())
  status       String       @default("PENDING")
  total_amount Decimal
  items        OrderItem[]
  customer     Customer     @relation(fields: [customer_id], references: [customer_id])
  transaction  Transaction?

  @@map("orders")
}

model OrderItem {
  order_item_id Int     @id @default(autoincrement())
  order_id      Int
  product_id    Int
  quantity      Int
  price         Decimal
  order         Order   @relation(fields: [order_id], references: [order_id])
  product       Product @relation(fields: [product_id], references: [product_id])

  @@map("order_items")
}

model Transaction {
  transaction_id Int               @id @default(autoincrement())
  receipt_no     String            @unique @default(uuid())
  created_at     DateTime          @default(now())
  user_id        Int
  customer_id    Int?
  order_id       Int?              @unique
  total_amount   Decimal
  status         String            @default("COMPLETED")
  payment        Payment?
  items          TransactionItem[]
  customer       Customer?         @relation(fields: [customer_id], references: [customer_id])
  order          Order?            @relation(fields: [order_id], references: [order_id])
  user           User              @relation(fields: [user_id], references: [user_id])

  @@map("transactions")
}

model TransactionItem {
  transaction_item_id Int         @id @default(autoincrement())
  transaction_id      Int
  product_id          Int
  quantity            Int
  price_at_sale       Decimal     @db.Decimal(10, 2)
  subtotal            Decimal     @db.Decimal(10, 2)
  cost_at_sale        Decimal     @default(0) @db.Decimal(10, 2)
  product             Product     @relation(fields: [product_id], references: [product_id])
  transaction         Transaction @relation(fields: [transaction_id], references: [transaction_id])

  @@map("transaction_items")
}

model Payment {
  payment_id         Int         @id @default(autoincrement())
  transaction_id     Int         @unique
  payment_method     String
  amount_tendered    Decimal
  change             Decimal
  gcash_reference_no String?
  transaction        Transaction @relation(fields: [transaction_id], references: [transaction_id])

  @@map("payments")
}

model SalesForecast {
  sales_forecast_id Int      @id @default(autoincrement())
  product_id        Int
  forecast_date     DateTime
  expected_sales    Int
  product           Product  @relation(fields: [product_id], references: [product_id])

  @@map("sales_forecasts")
}

/// Singleton table for store-wide settings
/// Should only ever have one row (id = 1)
model StoreSettings {
  id                 Int      @id @default(autoincrement())
  gcash_qr_image_url String?
  store_name         String   @default("Christian Minimart")
  store_address      String?
  store_contact      String?
  created_at         DateTime @default(now())
  updated_at         DateTime @updatedAt

  @@map("store_settings")
}

/// Notification model for real-time alerts
/// Used for polling-based notification system
model Notification {
  id          String   @id @default(uuid())
  user_id     Int      // Can be User ID (staff) or Customer ID (vendor)
  user_type   String   // "staff" or "vendor" to distinguish recipient type
  title       String
  message     String
  type        String   @default("info") // "info", "success", "warning", "error"
  is_read     Boolean  @default(false)
  href        String?  // Optional link to navigate to
  created_at  DateTime @default(now())

  @@index([user_id, user_type, is_read])
  @@map("notifications")
}

// =============================================================================
// ENTERPRISE ERP: Forecasting & Intelligence Module
// =============================================================================

/// Event sources for the forecasting system
/// STORE_DISCOUNT: Store-initiated promotions
/// MANUFACTURER_CAMPAIGN: External brand advertising (TV ads, etc.)
/// HOLIDAY: Public holidays affecting sales
enum EventSource {
  STORE_DISCOUNT
  MANUFACTURER_CAMPAIGN
  HOLIDAY
}

/// Event Log for tracking external factors affecting sales
/// Used by the forecasting engine to distinguish organic vs event-driven spikes
/// Critical for accurate demand forecasting
model EventLog {
  id                 Int           @id @default(autoincrement())
  name               String        // e.g., "Coke Christmas Ad", "Store Anniversary Sale"
  description        String?       // Optional detailed description
  source             EventSource   // Type of event
  start_date         DateTime
  end_date           DateTime
  multiplier         Decimal       @default(1.0) @db.Decimal(4, 2) // Expected sales multiplier
  affected_brand     String?       // Brand name (for manufacturer campaigns)
  affected_category  String?       // Product category (optional filter)
  is_active          Boolean       @default(true) // Whether event is active
  created_by         String?       // Who logged this event (user/chatbot/system)
  created_at         DateTime      @default(now())
  updated_at         DateTime      @updatedAt

  // Many-to-many relation with products
  products           EventLogProduct[]

  @@index([start_date, end_date])
  @@index([source])
  @@index([affected_brand])
  @@map("event_logs")
}

/// Junction table for EventLog <-> Product many-to-many relation
model EventLogProduct {
  id           Int      @id @default(autoincrement())
  event_id     Int
  product_id   Int
  event        EventLog @relation(fields: [event_id], references: [id], onDelete: Cascade)
  product      Product  @relation(fields: [product_id], references: [product_id], onDelete: Cascade)

  @@unique([event_id, product_id])
  @@map("event_log_products")
}

/// Historical daily sales aggregation for forecasting
/// Pre-aggregated data for faster forecast calculations
model DailySalesAggregate {
  id              Int       @id @default(autoincrement())
  product_id      Int
  date            DateTime  @db.Date
  quantity_sold   Int
  revenue         Decimal   @db.Decimal(12, 2)
  cost            Decimal   @db.Decimal(12, 2)
  profit          Decimal   @db.Decimal(12, 2)
  transaction_count Int     @default(1)
  is_event_day    Boolean   @default(false) // Whether this day had an active event
  event_source    EventSource? // What type of event (if any)
  event_id        Int?      // Reference to the event (if any)

  @@unique([product_id, date])
  @@index([product_id])
  @@index([date])
  @@index([is_event_day])
  @@map("daily_sales_aggregates")
}
