generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id        Int             @id @default(autoincrement())
  username       String          @unique
  password_hash  String
  role           String          @default("CASHIER")
  status         String          @default("ACTIVE")
  deletedAt      DateTime?
  stockMovements StockMovement[]
  transactions   Transaction[]

  @@index([deletedAt])
  @@map("users")
}

model Customer {
  customer_id     Int           @id @default(autoincrement())
  name            String
  contact_details String?
  email           String?       @unique
  password_hash   String?
  avatar_url      String?
  is_vendor       Boolean       @default(false)
  status          String        @default("ACTIVE")
  deletedAt       DateTime?
  orders          Order[]
  transactions    Transaction[]

  @@index([deletedAt])
  @@map("customers")
}

model Product {
  product_id          Int               @id @default(autoincrement())
  product_name        String
  category            String
  retail_price        Decimal
  wholesale_price     Decimal
  barcode             String?           @unique
  image_url           String?
  cost_price          Decimal           @default(0) @db.Decimal(10, 2)
  status              String            @default("ACTIVE")
  deletedAt           DateTime?
  is_archived         Boolean           @default(false)
  nearest_expiry_date DateTime?
  eventLogs           EventLogProduct[]
  inventory           Inventory?
  batches             InventoryBatch[]
  orderItems          OrderItem[]
  salesForecasts      SalesForecast[]
  transactionItems    TransactionItem[]

  @@index([deletedAt])
  @@map("products")
}

model Inventory {
  inventory_id    Int             @id @default(autoincrement())
  product_id      Int             @unique
  current_stock   Int             @default(0)
  allocated_stock Int             @default(0)
  reorder_level   Int             @default(10)
  auto_reorder    Boolean         @default(true)
  lead_time_days  Int             @default(7)
  last_restock    DateTime        @updatedAt
  product         Product         @relation(fields: [product_id], references: [product_id])
  stockMovements  StockMovement[]

  @@map("inventory")
}

/// Individual batch of inventory received from supplier
/// Each restock creates a new batch to track expiry dates granularly
/// Stock is deducted from oldest-expiring batches first (FEFO algorithm)
model InventoryBatch {
  id            Int       @id @default(autoincrement())
  product_id    Int
  quantity      Int
  expiry_date   DateTime?
  received_date DateTime  @default(now())
  supplier_ref  String?
  supplier_name String?   // Legacy: Kept for backward compatibility
  supplier_id   Int?      // New: Foreign key to Supplier
  cost_price    Decimal?  @db.Decimal(10, 2)
  status        String    @default("ACTIVE")
  deletedAt     DateTime?
  created_at    DateTime  @default(now())
  updated_at    DateTime  @updatedAt
  product       Product   @relation(fields: [product_id], references: [product_id], onDelete: Cascade)
  supplier      Supplier? @relation(fields: [supplier_id], references: [id])

  @@index([product_id])
  @@index([expiry_date])
  @@index([quantity])
  @@index([deletedAt])
  @@index([supplier_id])
  @@map("inventory_batches")
}

/// Supplier entity for managing vendor relationships
/// Links to inventory batches (restocks) and returns for ledger tracking
model Supplier {
  id             Int              @id @default(autoincrement())
  name           String           @unique
  contact_person String?
  contact_number String?
  email          String?
  address        String?
  notes          String?
  status         String           @default("ACTIVE") // ACTIVE, ARCHIVED
  created_at     DateTime         @default(now())
  updated_at     DateTime         @updatedAt
  batches        InventoryBatch[] // Deliveries from this supplier
  stockMovements StockMovement[]  // Returns to this supplier

  @@index([name])
  @@index([status])
  @@map("suppliers")
}

/// Audit log for all inventory stock changes
/// Every stock change MUST be logged here for accountability
model StockMovement {
  id                Int               @id @default(autoincrement())
  inventory_id      Int
  user_id           Int
  movement_type     StockMovementType
  quantity_change   Int
  previous_stock    Int
  new_stock         Int
  reason            String?
  reference         String?
  supplier_name     String?           // Legacy: Kept for backward compatibility
  supplier_id       Int?              // New: Foreign key to Supplier
  cost_price        Decimal?          @db.Decimal(10, 2)
  receipt_image_url String?
  created_at        DateTime          @default(now())
  inventory         Inventory         @relation(fields: [inventory_id], references: [inventory_id])
  user              User              @relation(fields: [user_id], references: [user_id])
  supplier          Supplier?         @relation(fields: [supplier_id], references: [id])

  @@index([inventory_id])
  @@index([user_id])
  @@index([movement_type])
  @@index([created_at])
  @@index([supplier_id])
  @@map("stock_movements")
}

model Order {
  order_id     Int          @id @default(autoincrement())
  customer_id  Int
  order_date   DateTime     @default(now())
  status       String       @default("PENDING")
  total_amount Decimal
  items        OrderItem[]
  customer     Customer     @relation(fields: [customer_id], references: [customer_id])
  transaction  Transaction?

  @@index([status])
  @@index([order_date])
  @@index([customer_id])
  @@map("orders")
}

model OrderItem {
  order_item_id Int     @id @default(autoincrement())
  order_id      Int
  product_id    Int
  quantity      Int
  price         Decimal
  order         Order   @relation(fields: [order_id], references: [order_id])
  product       Product @relation(fields: [product_id], references: [product_id])

  @@map("order_items")
}

model Transaction {
  transaction_id Int               @id @default(autoincrement())
  receipt_no     String            @unique @default(uuid())
  created_at     DateTime          @default(now())
  user_id        Int
  customer_id    Int?
  order_id       Int?              @unique
  total_amount   Decimal
  status         String            @default("COMPLETED")
  payment        Payment?
  items          TransactionItem[]
  customer       Customer?         @relation(fields: [customer_id], references: [customer_id])
  order          Order?            @relation(fields: [order_id], references: [order_id])
  user           User              @relation(fields: [user_id], references: [user_id])

  @@index([created_at])
  @@index([status])
  @@index([user_id])
  @@index([created_at, status])
  @@map("transactions")
}

model TransactionItem {
  transaction_item_id Int         @id @default(autoincrement())
  transaction_id      Int
  product_id          Int
  quantity            Int
  price_at_sale       Decimal     @db.Decimal(10, 2)
  subtotal            Decimal     @db.Decimal(10, 2)
  cost_at_sale        Decimal     @default(0) @db.Decimal(10, 2)
  product             Product     @relation(fields: [product_id], references: [product_id])
  transaction         Transaction @relation(fields: [transaction_id], references: [transaction_id])

  @@index([transaction_id])
  @@index([product_id])
  @@map("transaction_items")
}

model Payment {
  payment_id         Int         @id @default(autoincrement())
  transaction_id     Int         @unique
  payment_method     String
  amount_tendered    Decimal
  change             Decimal
  gcash_reference_no String?
  transaction        Transaction @relation(fields: [transaction_id], references: [transaction_id])

  @@map("payments")
}

model SalesForecast {
  sales_forecast_id Int      @id @default(autoincrement())
  product_id        Int
  forecast_date     DateTime
  expected_sales    Int
  product           Product  @relation(fields: [product_id], references: [product_id])

  @@map("sales_forecasts")
}

/// Audit log for tracking administrative changes (not sales transactions)
/// Every product/inventory modification should be logged here
model AuditLog {
  id          Int         @id @default(autoincrement())
  user_id     Int?
  username    String
  action      AuditAction
  module      String?
  entity_type String
  entity_id   Int?
  entity_name String
  details     String
  metadata    Json?
  ip_address  String?
  created_at  DateTime    @default(now())

  @@index([user_id])
  @@index([action])
  @@index([entity_type])
  @@index([module])
  @@index([created_at])
  @@map("audit_logs")
}

/// Singleton table for store-wide settings
/// Should only ever have one row (id = 1)
model StoreSettings {
  id                 Int      @id @default(autoincrement())
  gcash_qr_image_url String?
  store_name         String   @default("Christian Minimart")
  store_address      String?
  store_contact      String?
  created_at         DateTime @default(now())
  updated_at         DateTime @updatedAt

  @@map("store_settings")
}

/// Notification model for real-time alerts
/// Used for polling-based notification system
model Notification {
  id         String   @id @default(uuid())
  user_id    Int
  user_type  String
  title      String
  message    String
  type       String   @default("info")
  is_read    Boolean  @default(false)
  href       String?
  created_at DateTime @default(now())

  @@index([user_id, user_type, is_read])
  @@map("notifications")
}

/// Event Log for tracking external factors affecting sales
/// Used by the forecasting engine to distinguish organic vs event-driven spikes
/// Critical for accurate demand forecasting
model EventLog {
  id                Int               @id @default(autoincrement())
  name              String
  description       String?
  source            EventSource
  start_date        DateTime
  end_date          DateTime
  multiplier        Decimal           @default(1.0) @db.Decimal(4, 2)
  affected_brand    String?
  affected_category String?
  is_active         Boolean           @default(true)
  created_by        String?
  created_at        DateTime          @default(now())
  updated_at        DateTime          @updatedAt
  products          EventLogProduct[]

  @@index([start_date, end_date])
  @@index([source])
  @@index([affected_brand])
  @@map("event_logs")
}

/// Junction table for EventLog <-> Product many-to-many relation
model EventLogProduct {
  id         Int      @id @default(autoincrement())
  event_id   Int
  product_id Int
  event      EventLog @relation(fields: [event_id], references: [id], onDelete: Cascade)
  product    Product  @relation(fields: [product_id], references: [product_id], onDelete: Cascade)

  @@unique([event_id, product_id])
  @@map("event_log_products")
}

/// Historical daily sales aggregation for forecasting
/// Pre-aggregated data for faster forecast calculations
model DailySalesAggregate {
  id                Int          @id @default(autoincrement())
  product_id        Int
  date              DateTime     @db.Date
  quantity_sold     Int
  revenue           Decimal      @db.Decimal(12, 2)
  cost              Decimal      @db.Decimal(12, 2)
  profit            Decimal      @db.Decimal(12, 2)
  transaction_count Int          @default(1)
  is_event_day      Boolean      @default(false)
  event_source      EventSource?
  event_id          Int?

  @@unique([product_id, date])
  @@index([product_id])
  @@index([date])
  @@index([is_event_day])
  @@map("daily_sales_aggregates")
}

/// Types of stock movements for audit trail
/// INITIAL_STOCK: Initial stock when product is created
/// RESTOCK: Adding stock from supplier
/// SALE: Stock removed due to sale (automatic)
/// ADJUSTMENT: Manual adjustment (audit, correction)
/// DAMAGE: Stock removed due to damage/spoilage
/// RETURN: Stock added back from customer return
/// SUPPLIER_RETURN: Stock returned to supplier (expired, damaged, recalled)
/// INTERNAL_USE: Stock used internally (not sold)
/// ORDER_SHORTAGE: Stock removed when item marked unavailable in order
enum StockMovementType {
  INITIAL_STOCK
  RESTOCK
  SALE
  ADJUSTMENT
  DAMAGE
  RETURN
  SUPPLIER_RETURN
  INTERNAL_USE
  ORDER_SHORTAGE
}

/// Action types for audit log entries
enum AuditAction {
  CREATE
  UPDATE
  DELETE
  ARCHIVE
  RESTORE
  ADJUST_STOCK
  RESTOCK
  BATCH_RESTOCK
  BATCH_RETURN
  BULK_IMPORT
  ORDER_CANCEL
  EDIT_EXPIRY
  EDIT_BATCH
  LOGIN
  LOGIN_FAILED
  LOGOUT
  ZREAD_CLOSE
  VENDOR_REGISTER
}

/// Event sources for the forecasting system
/// STORE_DISCOUNT: Store-initiated promotions
/// MANUFACTURER_CAMPAIGN: External brand advertising (TV ads, etc.)
/// HOLIDAY: Public holidays affecting sales
enum EventSource {
  STORE_DISCOUNT
  MANUFACTURER_CAMPAIGN
  HOLIDAY
}
