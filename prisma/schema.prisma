generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id        Int             @id @default(autoincrement())
  username       String          @unique
  password_hash  String
  role           String          @default("CASHIER")
  status         String          @default("ACTIVE") // ACTIVE, ARCHIVED
  deletedAt      DateTime?       // Soft delete timestamp (null = active)
  transactions   Transaction[]
  stockMovements StockMovement[]

  @@index([deletedAt])
  @@map("users")
}

model Customer {
  customer_id     Int           @id @default(autoincrement())
  name            String
  contact_details String?
  email           String?       @unique
  password_hash   String?
  is_vendor       Boolean       @default(false)
  status          String        @default("ACTIVE") // ACTIVE, ARCHIVED
  deletedAt       DateTime?     // Soft delete timestamp (null = active)
  orders          Order[]
  transactions    Transaction[]

  @@index([deletedAt])
  @@map("customers")
}

model Product {
  product_id          Int               @id @default(autoincrement())
  product_name        String
  category            String
  retail_price        Decimal
  wholesale_price     Decimal
  barcode             String?           @unique
  image_url           String?
  cost_price          Decimal           @default(0) @db.Decimal(10, 2)
  status              String            @default("ACTIVE") // ACTIVE, ARCHIVED
  deletedAt           DateTime?         // Soft delete timestamp (null = active)
  is_archived         Boolean           @default(false) // DEPRECATED: Use deletedAt instead
  nearest_expiry_date DateTime?         // Computed from MIN(InventoryBatch.expiry_date) where quantity > 0
  inventory           Inventory?
  batches             InventoryBatch[]  // All stock batches for this product
  orderItems          OrderItem[]
  salesForecasts      SalesForecast[]
  transactionItems    TransactionItem[]
  eventLogs           EventLogProduct[] // Events affecting this product

  @@index([deletedAt])
  @@map("products")
}

model Inventory {
  inventory_id    Int             @id @default(autoincrement())
  product_id      Int             @unique
  current_stock   Int             @default(0)
  allocated_stock Int             @default(0) // Stock reserved in PENDING/PREPARING orders
  reorder_level   Int             @default(10)
  auto_reorder    Boolean         @default(true) // Use dynamic ROP based on velocity
  lead_time_days  Int             @default(7) // Days until next supplier delivery
  last_restock    DateTime        @updatedAt
  product         Product         @relation(fields: [product_id], references: [product_id])
  stockMovements  StockMovement[]

  @@map("inventory")
}

/// ============================================================================
/// BATCH TRACKING (FEFO - First Expired, First Out)
/// ============================================================================

/// Individual batch of inventory received from supplier
/// Each restock creates a new batch to track expiry dates granularly
/// Stock is deducted from oldest-expiring batches first (FEFO algorithm)
model InventoryBatch {
  id            Int       @id @default(autoincrement())
  product_id    Int
  quantity      Int       // Remaining quantity in this batch
  expiry_date   DateTime? // Expiration date of this batch (null = no expiry)
  received_date DateTime  @default(now()) // When this batch was received
  supplier_ref  String?   // Supplier invoice/reference number
  supplier_name String?   // Supplier name for this batch
  cost_price    Decimal?  @db.Decimal(10, 2) // Cost price for this batch
  status        String    @default("ACTIVE") // ACTIVE, ARCHIVED
  deletedAt     DateTime? // Soft delete timestamp (null = active)
  created_at    DateTime  @default(now())
  updated_at    DateTime  @updatedAt
  
  product       Product   @relation(fields: [product_id], references: [product_id], onDelete: Cascade)

  @@index([product_id])
  @@index([expiry_date])
  @@index([quantity]) // For quick "has stock" queries
  @@index([deletedAt])
  @@map("inventory_batches")
}

/// Types of stock movements for audit trail
/// INITIAL_STOCK: Initial stock when product is created
/// RESTOCK: Adding stock from supplier
/// SALE: Stock removed due to sale (automatic)
/// ADJUSTMENT: Manual adjustment (audit, correction)
/// DAMAGE: Stock removed due to damage/spoilage
/// RETURN: Stock added back from customer return
/// SUPPLIER_RETURN: Stock returned to supplier (expired, damaged, recalled)
/// INTERNAL_USE: Stock used internally (not sold)
/// ORDER_SHORTAGE: Stock removed when item marked unavailable in order
enum StockMovementType {
  INITIAL_STOCK
  RESTOCK
  SALE
  ADJUSTMENT
  DAMAGE
  RETURN
  SUPPLIER_RETURN
  INTERNAL_USE
  ORDER_SHORTAGE
}

/// Audit log for all inventory stock changes
/// Every stock change MUST be logged here for accountability
model StockMovement {
  id                Int               @id @default(autoincrement())
  inventory_id      Int
  user_id           Int
  movement_type     StockMovementType
  quantity_change   Int               // Positive for additions, negative for removals
  previous_stock    Int               // Stock before this movement
  new_stock         Int               // Stock after this movement
  reason            String?           // Optional reason/notes
  reference         String?           // Reference number (e.g., supplier invoice, receipt no)
  supplier_name     String?           // Supplier name for RESTOCK movements
  cost_price        Decimal?          @db.Decimal(10, 2) // Cost price at time of restock
  receipt_image_url String?           // Receipt/document image URL for RESTOCK/INITIAL_STOCK
  created_at        DateTime          @default(now())
  inventory         Inventory         @relation(fields: [inventory_id], references: [inventory_id])
  user              User              @relation(fields: [user_id], references: [user_id])

  @@index([inventory_id])
  @@index([user_id])
  @@index([movement_type])
  @@index([created_at])
  @@map("stock_movements")
}

model Order {
  order_id     Int          @id @default(autoincrement())
  customer_id  Int
  order_date   DateTime     @default(now())
  status       String       @default("PENDING")
  total_amount Decimal
  items        OrderItem[]
  customer     Customer     @relation(fields: [customer_id], references: [customer_id])
  transaction  Transaction?

  @@index([status]) // ⚡ Perf: Fast status-based filtering
  @@index([order_date]) // ⚡ Perf: Fast date range queries
  @@index([customer_id]) // ⚡ Perf: Fast customer order lookups
  @@map("orders")
}

model OrderItem {
  order_item_id Int     @id @default(autoincrement())
  order_id      Int
  product_id    Int
  quantity      Int
  price         Decimal
  order         Order   @relation(fields: [order_id], references: [order_id])
  product       Product @relation(fields: [product_id], references: [product_id])

  @@map("order_items")
}

model Transaction {
  transaction_id Int               @id @default(autoincrement())
  receipt_no     String            @unique @default(uuid())
  created_at     DateTime          @default(now())
  user_id        Int
  customer_id    Int?
  order_id       Int?              @unique
  total_amount   Decimal
  status         String            @default("COMPLETED")
  payment        Payment?
  items          TransactionItem[]
  customer       Customer?         @relation(fields: [customer_id], references: [customer_id])
  order          Order?            @relation(fields: [order_id], references: [order_id])
  user           User              @relation(fields: [user_id], references: [user_id])

  @@index([created_at]) // ⚡ Perf: Fast date range queries (sales history)
  @@index([status]) // ⚡ Perf: Fast status filtering (exclude VOID/CANCELLED)
  @@index([user_id]) // ⚡ Perf: Fast user transaction lookups
  @@index([created_at, status]) // ⚡ Perf: Compound index for sales reports
  @@map("transactions")
}

model TransactionItem {
  transaction_item_id Int         @id @default(autoincrement())
  transaction_id      Int
  product_id          Int
  quantity            Int
  price_at_sale       Decimal     @db.Decimal(10, 2)
  subtotal            Decimal     @db.Decimal(10, 2)
  cost_at_sale        Decimal     @default(0) @db.Decimal(10, 2)
  product             Product     @relation(fields: [product_id], references: [product_id])
  transaction         Transaction @relation(fields: [transaction_id], references: [transaction_id])

  @@index([transaction_id]) // ⚡ Perf: Fast transaction item lookups
  @@index([product_id]) // ⚡ Perf: Fast product sales history
  @@map("transaction_items")
}

model Payment {
  payment_id         Int         @id @default(autoincrement())
  transaction_id     Int         @unique
  payment_method     String
  amount_tendered    Decimal
  change             Decimal
  gcash_reference_no String?
  transaction        Transaction @relation(fields: [transaction_id], references: [transaction_id])

  @@map("payments")
}

model SalesForecast {
  sales_forecast_id Int      @id @default(autoincrement())
  product_id        Int
  forecast_date     DateTime
  expected_sales    Int
  product           Product  @relation(fields: [product_id], references: [product_id])

  @@map("sales_forecasts")
}

// =============================================================================
// AUDIT LOG: Track administrative actions for accountability
// =============================================================================

/// Action types for audit log entries
enum AuditAction {
  CREATE
  UPDATE
  DELETE
  ARCHIVE
  RESTORE
  ADJUST_STOCK
  RESTOCK
  BULK_IMPORT
  ORDER_CANCEL
  EDIT_EXPIRY
  EDIT_BATCH
}

/// Audit log for tracking administrative changes (not sales transactions)
/// Every product/inventory modification should be logged here
model AuditLog {
  id          Int         @id @default(autoincrement())
  user_id     Int?        // User who performed the action (null for system actions)
  username    String      // Username for display (denormalized for historical accuracy)
  action      AuditAction // Type of action performed
  module      String?     // System area: INVENTORY, POS, CATALOG, AUTH, ORDERS
  entity_type String      // "Product", "Inventory", "StockMovement", etc.
  entity_id   Int?        // ID of the affected entity
  entity_name String      // Name of the entity (e.g., product name)
  details     String      // Human-readable description of the change
  metadata    Json?       // Additional structured data (old values, new values, etc.)
  ip_address  String?     // Optional IP address for security auditing
  created_at  DateTime    @default(now())

  @@index([user_id])
  @@index([action])
  @@index([entity_type])
  @@index([module])
  @@index([created_at])
  @@map("audit_logs")
}

/// Singleton table for store-wide settings
/// Should only ever have one row (id = 1)
model StoreSettings {
  id                 Int      @id @default(autoincrement())
  gcash_qr_image_url String?
  store_name         String   @default("Christian Minimart")
  store_address      String?
  store_contact      String?
  created_at         DateTime @default(now())
  updated_at         DateTime @updatedAt

  @@map("store_settings")
}

/// Notification model for real-time alerts
/// Used for polling-based notification system
model Notification {
  id          String   @id @default(uuid())
  user_id     Int      // Can be User ID (staff) or Customer ID (vendor)
  user_type   String   // "staff" or "vendor" to distinguish recipient type
  title       String
  message     String
  type        String   @default("info") // "info", "success", "warning", "error"
  is_read     Boolean  @default(false)
  href        String?  // Optional link to navigate to
  created_at  DateTime @default(now())

  @@index([user_id, user_type, is_read])
  @@map("notifications")
}

// =============================================================================
// ENTERPRISE ERP: Forecasting & Intelligence Module
// =============================================================================

/// Event sources for the forecasting system
/// STORE_DISCOUNT: Store-initiated promotions
/// MANUFACTURER_CAMPAIGN: External brand advertising (TV ads, etc.)
/// HOLIDAY: Public holidays affecting sales
enum EventSource {
  STORE_DISCOUNT
  MANUFACTURER_CAMPAIGN
  HOLIDAY
}

/// Event Log for tracking external factors affecting sales
/// Used by the forecasting engine to distinguish organic vs event-driven spikes
/// Critical for accurate demand forecasting
model EventLog {
  id                 Int           @id @default(autoincrement())
  name               String        // e.g., "Coke Christmas Ad", "Store Anniversary Sale"
  description        String?       // Optional detailed description
  source             EventSource   // Type of event
  start_date         DateTime
  end_date           DateTime
  multiplier         Decimal       @default(1.0) @db.Decimal(4, 2) // Expected sales multiplier
  affected_brand     String?       // Brand name (for manufacturer campaigns)
  affected_category  String?       // Product category (optional filter)
  is_active          Boolean       @default(true) // Whether event is active
  created_by         String?       // Who logged this event (user/chatbot/system)
  created_at         DateTime      @default(now())
  updated_at         DateTime      @updatedAt

  // Many-to-many relation with products
  products           EventLogProduct[]

  @@index([start_date, end_date])
  @@index([source])
  @@index([affected_brand])
  @@map("event_logs")
}

/// Junction table for EventLog <-> Product many-to-many relation
model EventLogProduct {
  id           Int      @id @default(autoincrement())
  event_id     Int
  product_id   Int
  event        EventLog @relation(fields: [event_id], references: [id], onDelete: Cascade)
  product      Product  @relation(fields: [product_id], references: [product_id], onDelete: Cascade)

  @@unique([event_id, product_id])
  @@map("event_log_products")
}

/// Historical daily sales aggregation for forecasting
/// Pre-aggregated data for faster forecast calculations
model DailySalesAggregate {
  id              Int       @id @default(autoincrement())
  product_id      Int
  date            DateTime  @db.Date
  quantity_sold   Int
  revenue         Decimal   @db.Decimal(12, 2)
  cost            Decimal   @db.Decimal(12, 2)
  profit          Decimal   @db.Decimal(12, 2)
  transaction_count Int     @default(1)
  is_event_day    Boolean   @default(false) // Whether this day had an active event
  event_source    EventSource? // What type of event (if any)
  event_id        Int?      // Reference to the event (if any)

  @@unique([product_id, date])
  @@index([product_id])
  @@index([date])
  @@index([is_event_day])
  @@map("daily_sales_aggregates")
}
